---
title: 'Custom Tools & Credential Management'
description: 'Extend DroidRun agents with custom tools and secure credential storage'
---

# Custom Tools & Credential Management

DroidRun provides a powerful system for extending agent capabilities through **custom tools** and managing sensitive data through **credential management**. This guide covers both systems in detail.

---

## Overview

### Custom Tools
Custom tools are user-defined functions that extend the agent's capabilities beyond the built-in atomic actions (click, type, swipe, etc.). Use custom tools to:
- Integrate with external APIs (webhooks, REST APIs)
- Perform complex computations
- Access third-party services
- Implement domain-specific actions

### Credential Management
The credential manager provides secure storage and retrieval of sensitive data like passwords, API keys, and tokens. Credentials are:
- Stored securely in encrypted format
- Never logged or exposed in output
- Automatically injected as custom tools
- Accessible to all agents (Manager, Executor, CodeAct)

---

## Custom Tools

### Architecture

Custom tools are defined as Python dictionaries following this structure:

```python
custom_tools = {
    "tool_name": {
        "arguments": ["arg1", "arg2"],  # List of parameter names
        "description": "Tool description with usage example",  # For LLM prompt
        "function": callable_function  # Python function to execute
    }
}
```

The custom tool system merges seamlessly with atomic actions:
- **Atomic actions** (click, type, swipe, etc.) are always available
- **Custom tools** are added on top and accessible in the same way
- Both Manager and Executor agents can reference custom tools in their planning

### Creating Custom Tools

#### Basic Example: Webhook Integration

```python
#!/usr/bin/env python3
import asyncio
import requests
from droidrun import AdbTools, DroidAgent
from llama_index.llms.google_genai import GoogleGenAI

def send_webhook(tool_instance, url: str, data: str) -> str:
    """
    Send data to a webhook URL.

    Args:
        tool_instance: Tools instance (required by DroidRun)
        url: Webhook URL
        data: Data to send (JSON string or plain text)

    Returns:
        Result message
    """
    try:
        response = requests.post(url, json={"data": data}, timeout=10)
        response.raise_for_status()
        return f"Webhook sent successfully. Status: {response.status_code}"
    except Exception as e:
        return f"Error sending webhook: {str(e)}"

# Define custom tool
custom_tools = {
    "send_webhook": {
        "arguments": ["url", "data"],
        "description": 'Send data to a webhook URL. Usage: {"action": "send_webhook", "url": "https://webhook.site/abc123", "data": "your data here"}',
        "function": send_webhook,
    }
}

async def main():
    tools = AdbTools()
    llm = GoogleGenAI(model="models/gemini-2.5-flash")

    agent = DroidAgent(
        goal="Check my Gmail unread count and send it to webhook https://webhook.site/abc123",
        llm=llm,
        tools=tools,
        custom_tools=custom_tools  # Pass custom tools here
    )

    result = await agent.run()
    print(f"Success: {result['success']}")
    print(f"Reason: {result['reason']}")

if __name__ == "__main__":
    asyncio.run(main())
```

#### Advanced Example: API Integration

```python
import json
import requests
from typing import Dict

def fetch_weather(tool_instance, city: str) -> str:
    """
    Fetch weather data for a city.

    Args:
        tool_instance: Tools instance
        city: City name

    Returns:
        Weather information as string
    """
    try:
        # Example using OpenWeatherMap API
        api_key = "your_api_key_here"  # Or use credential manager
        url = f"https://api.openweathermap.org/data/2.5/weather?q={city}&appid={api_key}"
        response = requests.get(url, timeout=10)
        response.raise_for_status()

        data = response.json()
        temp = data["main"]["temp"] - 273.15  # Convert to Celsius
        weather = data["weather"][0]["description"]

        return f"Weather in {city}: {weather}, {temp:.1f}Â°C"
    except Exception as e:
        return f"Error fetching weather: {str(e)}"

def save_to_database(tool_instance, table: str, data: str) -> str:
    """
    Save data to a database.

    Args:
        tool_instance: Tools instance
        table: Table name
        data: JSON data to save

    Returns:
        Result message
    """
    try:
        # Parse JSON data
        json_data = json.loads(data)

        # Example database operation (pseudo-code)
        # db.insert(table, json_data)

        return f"Data saved to {table}: {len(json_data)} records"
    except json.JSONDecodeError:
        return "Error: Invalid JSON data"
    except Exception as e:
        return f"Error saving to database: {str(e)}"

custom_tools = {
    "fetch_weather": {
        "arguments": ["city"],
        "description": 'Fetch current weather for a city. Usage: {"action": "fetch_weather", "city": "London"}',
        "function": fetch_weather,
    },
    "save_to_database": {
        "arguments": ["table", "data"],
        "description": 'Save JSON data to database table. Usage: {"action": "save_to_database", "table": "users", "data": "{\\"name\\": \\"John\\", \\"age\\": 30}"}',
        "function": save_to_database,
    }
}
```

### Custom Tool Function Signature

All custom tool functions **must** follow this signature:

```python
def tool_function(tool_instance: Tools, arg1: type, arg2: type, ...) -> str:
    """
    Tool description.

    Args:
        tool_instance: Tools instance (REQUIRED as first parameter)
        arg1: Description of argument 1
        arg2: Description of argument 2

    Returns:
        Result message (string)
    """
    # Implementation
    return "result"
```

**Important:**
- First parameter MUST be `tool_instance: Tools` (even if not used)
- Return type should be `str` (agents expect string responses)
- Async functions are supported (use `async def`)
- Exceptions should be caught and returned as error messages

### Async Custom Tools

For async operations, use `async def`:

```python
import asyncio
import aiohttp

async def fetch_async(tool_instance, url: str) -> str:
    """Fetch data asynchronously."""
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(url, timeout=10) as response:
                data = await response.text()
                return f"Fetched {len(data)} bytes"
    except Exception as e:
        return f"Error: {str(e)}"

custom_tools = {
    "fetch_async": {
        "arguments": ["url"],
        "description": 'Fetch data from URL asynchronously. Usage: {"action": "fetch_async", "url": "https://api.example.com/data"}',
        "function": fetch_async,
    }
}
```

### How Custom Tools Work

1. **Tool Registration**: Custom tools are passed to `DroidAgent` via the `custom_tools` parameter
2. **Tool Merging**: Custom tools are merged with atomic actions (click, type, swipe, etc.)
3. **Prompt Injection**: Tool descriptions are injected into agent prompts
4. **Execution**: When an agent selects a custom tool, DroidRun calls the function with the provided arguments

```python
# Internal flow (you don't need to implement this)
# 1. Agent receives custom tool descriptions in prompt
# 2. Agent decides to use custom tool: {"action": "send_webhook", "url": "...", "data": "..."}
# 3. DroidRun calls: send_webhook(tools_instance, url="...", data="...")
# 4. Result is returned to agent for next step
```

### Best Practices for Custom Tools

<AccordionGroup>
  <Accordion title="1. Clear Descriptions">
    Write detailed descriptions with usage examples for the LLM:

    ```python
    # Good
    "description": 'Send POST request to webhook URL with JSON payload. Usage: {"action": "send_webhook", "url": "https://webhook.site/abc", "data": "{\\"key\\": \\"value\\"}"}',

    # Bad
    "description": "Send webhook",
    ```
  </Accordion>

  <Accordion title="2. Error Handling">
    Always catch exceptions and return meaningful error messages:

    ```python
    def robust_tool(tool_instance, url: str) -> str:
        try:
            response = requests.get(url, timeout=10)
            response.raise_for_status()
            return f"Success: {response.status_code}"
        except requests.Timeout:
            return "Error: Request timed out after 10 seconds"
        except requests.RequestException as e:
            return f"Error: HTTP request failed - {str(e)}"
        except Exception as e:
            return f"Error: Unexpected error - {str(e)}"
    ```
  </Accordion>

  <Accordion title="3. Argument Validation">
    Validate inputs before processing:

    ```python
    def validated_tool(tool_instance, count: int) -> str:
        if not isinstance(count, int):
            return "Error: count must be an integer"
        if count < 0 or count > 100:
            return "Error: count must be between 0 and 100"

        # Process valid input
        return f"Processed {count} items"
    ```
  </Accordion>

  <Accordion title="4. Timeout Handling">
    Add timeouts to network operations:

    ```python
    def api_call(tool_instance, endpoint: str) -> str:
        try:
            response = requests.get(endpoint, timeout=10)  # Always set timeout
            return response.text
        except requests.Timeout:
            return "Error: API call timed out"
    ```
  </Accordion>

  <Accordion title="5. Logging (Optional)">
    Use Python logging for debugging (logs appear in DroidRun output):

    ```python
    import logging
    logger = logging.getLogger("droidrun")

    def logged_tool(tool_instance, data: str) -> str:
        logger.info(f"Processing data: {data[:50]}...")  # Log first 50 chars
        # Process data
        logger.info("Processing complete")
        return "Success"
    ```
  </Accordion>
</AccordionGroup>

---

## Credential Management

### Overview

The credential manager provides secure storage for sensitive data like passwords, API keys, and authentication tokens. Credentials are:
- **Encrypted at rest** using the `cryptography` library
- **Never logged** or exposed in output
- **Automatically available** as custom tools via `type_secret`
- **Access-logged** for audit purposes

### Setting Up Credentials

#### Method 1: Configuration File (Recommended)

1. **Create credentials file** (`credentials.yaml`):

```yaml
# credentials.yaml
secrets:
  # Dict format (recommended)
  MY_PASSWORD:
    value: "your_password_here"
    enabled: true

  GMAIL_PASSWORD:
    value: "gmail_pass_123"
    enabled: true

  API_KEY:
    value: "sk-1234567890abcdef"
    enabled: true

  # Simple string format (auto-enabled)
  WEBHOOK_TOKEN: "webhook_secret_token"

  # Disabled secret (not loaded)
  OLD_PASSWORD:
    value: "old_pass"
    enabled: false  # This secret will NOT be available
```

2. **Enable in config.yaml**:

```yaml
# config.yaml
credentials:
  enabled: true
  file_path: credentials.yaml  # Path relative to working directory
```

3. **Use in your script**:

```python
#!/usr/bin/env python3
import asyncio
from droidrun import AdbTools, DroidAgent
from droidrun.config_manager.config import DroidRunConfig
from llama_index.llms.google_genai import GoogleGenAI

async def main():
    # Load config (includes credentials)
    config = DroidRunConfig()
    config.credentials.enabled = True
    config.credentials.file_path = "credentials.yaml"

    tools = AdbTools()
    llm = GoogleGenAI(model="models/gemini-2.5-flash")

    agent = DroidAgent(
        goal="Login to my Gmail account",
        llm=llm,
        tools=tools,
        config=config  # Credentials loaded from config
    )

    result = await agent.run()
    print(f"Success: {result['success']}")

if __name__ == "__main__":
    asyncio.run(main())
```

#### Method 2: In-Memory Credentials (Programmatic)

Pass credentials directly as a dictionary:

```python
#!/usr/bin/env python3
import asyncio
from droidrun import AdbTools, DroidAgent
from llama_index.llms.google_genai import GoogleGenAI

async def main():
    # Define credentials in-memory
    credentials = {
        "MY_PASSWORD": "secret123",
        "API_KEY": "sk-1234567890abcdef"
    }

    tools = AdbTools()
    llm = GoogleGenAI(model="models/gemini-2.5-flash")

    agent = DroidAgent(
        goal="Login to my account",
        llm=llm,
        tools=tools,
        credentials=credentials  # Pass directly
    )

    result = await agent.run()
    print(f"Success: {result['success']}")

if __name__ == "__main__":
    asyncio.run(main())
```

### Using Credentials in Agents

When credentials are enabled, the `type_secret` custom tool is automatically injected. Agents can use it to type secrets into input fields without exposing values.

#### How Agents Use Credentials

The agent receives available secret IDs in the system prompt:

```
## Available Secrets:
The credential manager has the following secret IDs available:
- MY_PASSWORD
- GMAIL_PASSWORD
- API_KEY
```

The agent then uses `type_secret` to input credentials:

```python
# Agent's generated code (CodeAct mode)
type_secret("MY_PASSWORD", index=5)

# Or in Executor mode (JSON format)
{"action": "type_secret", "secret_id": "MY_PASSWORD", "index": 5}
```

#### Example: Login Automation

```python
#!/usr/bin/env python3
import asyncio
from droidrun import AdbTools, DroidAgent
from llama_index.llms.google_genai import GoogleGenAI

async def main():
    # Define credentials
    credentials = {
        "EMAIL_USER": "user@example.com",
        "EMAIL_PASS": "secret_password_123"
    }

    tools = AdbTools()
    llm = GoogleGenAI(model="models/gemini-2.5-flash")

    agent = DroidAgent(
        goal="Open Gmail app and login with my credentials",
        llm=llm,
        tools=tools,
        credentials=credentials
    )

    result = await agent.run()
    print(f"Success: {result['success']}")
    print(f"Result: {result['reason']}")

if __name__ == "__main__":
    asyncio.run(main())
```

**What the agent does internally:**
1. Opens Gmail app using `open_app("Gmail")`
2. Clicks on email input field: `click(index=3)`
3. Types email using regular type: `type("user@example.com", index=3)`
4. Clicks on password field: `click(index=5)`
5. Types password securely: `type_secret("EMAIL_PASS", index=5)`
6. Clicks login button: `click(index=7)`

### Credential Manager API

If you need direct access to credentials (e.g., for custom tools):

```python
from droidrun.credential_manager import CredentialManager

# Load from file
cm = CredentialManager(credentials_path="credentials.yaml")

# Load from dict
cm = CredentialManager(credentials_dict={"PASSWORD": "secret123"})

# Get secret value
password = cm.get_credential("PASSWORD")

# List available secrets
secret_ids = cm.list_available_secrets()  # ["PASSWORD", "API_KEY", ...]

# Check if secret exists
if cm.has_credential("API_KEY"):
    api_key = cm.get_credential("API_KEY")
```

### Security Features

<AccordionGroup>
  <Accordion title="1. No Logging">
    Secret values are **never** logged or displayed:

    ```
    â Logged: "ð Accessing secret: 'MY_PASSWORD'"
    â Never logged: "MY_PASSWORD value is: secret123"
    ```
  </Accordion>

  <Accordion title="2. Sanitized Errors">
    Error messages show secret IDs but never values:

    ```
    â Error message: "Secret 'WRONG_ID' not found. Available: ['MY_PASSWORD', 'API_KEY']"
    â Never shown: "Secret value 'secret123' is invalid"
    ```
  </Accordion>

  <Accordion title="3. Encrypted Storage">
    When using file-based credentials, consider encrypting `credentials.yaml`:

    ```bash
    # Example using gpg
    gpg --encrypt --recipient you@example.com credentials.yaml

    # Decrypt before running
    gpg --decrypt credentials.yaml.gpg > credentials.yaml
    droidrun run "your command"
    rm credentials.yaml  # Clean up after run
    ```
  </Accordion>

  <Accordion title="4. Git Ignore">
    **Always** add `credentials.yaml` to `.gitignore`:

    ```bash
    # .gitignore
    credentials.yaml
    credentials_*.yaml
    *.credentials.yaml
    ```
  </Accordion>

  <Accordion title="5. Environment Variables">
    For CI/CD, load credentials from environment variables:

    ```python
    import os

    credentials = {
        "PASSWORD": os.environ["APP_PASSWORD"],
        "API_KEY": os.environ["API_KEY"]
    }

    agent = DroidAgent(
        goal="...",
        llm=llm,
        tools=tools,
        credentials=credentials
    )
    ```
  </Accordion>
</AccordionGroup>

---

## Combining Custom Tools and Credentials

Custom tools can access credentials via the credential manager:

```python
#!/usr/bin/env python3
import asyncio
import requests
from droidrun import AdbTools, DroidAgent
from llama_index.llms.google_genai import GoogleGenAI

def send_authenticated_webhook(tool_instance, url: str, data: str) -> str:
    """
    Send data to webhook with API key authentication.

    Args:
        tool_instance: Tools instance
        url: Webhook URL
        data: Data to send

    Returns:
        Result message
    """
    try:
        # Access credential manager from tools instance
        if not hasattr(tool_instance, 'credential_manager') or tool_instance.credential_manager is None:
            return "Error: Credential manager not available"

        # Get API key from credential manager
        api_key = tool_instance.credential_manager.get_credential("WEBHOOK_API_KEY")

        # Send authenticated request
        headers = {"Authorization": f"Bearer {api_key}"}
        response = requests.post(url, json={"data": data}, headers=headers, timeout=10)
        response.raise_for_status()

        return f"Webhook sent successfully. Status: {response.status_code}"
    except Exception as e:
        return f"Error: {str(e)}"

async def main():
    # Define credentials
    credentials = {
        "WEBHOOK_API_KEY": "sk-webhook-secret-key",
        "EMAIL_PASSWORD": "email_pass_123"
    }

    # Define custom tool
    custom_tools = {
        "send_authenticated_webhook": {
            "arguments": ["url", "data"],
            "description": 'Send authenticated webhook. Usage: {"action": "send_authenticated_webhook", "url": "https://api.example.com/webhook", "data": "message"}',
            "function": send_authenticated_webhook,
        }
    }

    tools = AdbTools()
    llm = GoogleGenAI(model="models/gemini-2.5-flash")

    agent = DroidAgent(
        goal="Check my unread Gmail count and send to webhook https://api.example.com/webhook",
        llm=llm,
        tools=tools,
        credentials=credentials,
        custom_tools=custom_tools
    )

    result = await agent.run()
    print(f"Success: {result['success']}")

if __name__ == "__main__":
    asyncio.run(main())
```

---

## Custom Variables

DroidRun also supports **custom variables** - user-defined data accessible throughout execution without being secrets:

```python
#!/usr/bin/env python3
import asyncio
from droidrun import AdbTools, DroidAgent
from llama_index.llms.google_genai import GoogleGenAI

async def main():
    # Define custom variables (non-sensitive data)
    variables = {
        "target_email": "john@example.com",
        "subject_line": "Monthly Report",
        "cc_recipients": ["alice@example.com", "bob@example.com"]
    }

    tools = AdbTools()
    llm = GoogleGenAI(model="models/gemini-2.5-flash")

    agent = DroidAgent(
        goal="Compose email to target_email with subject_line and cc to cc_recipients",
        llm=llm,
        tools=tools,
        variables=variables  # Pass variables
    )

    result = await agent.run()
    print(f"Success: {result['success']}")

if __name__ == "__main__":
    asyncio.run(main())
```

**Difference between credentials and variables:**
- **Credentials**: Sensitive data (passwords, API keys) - never logged
- **Variables**: Non-sensitive data (emails, names) - available in prompts

---

## CLI Usage

### With Configuration File

```bash
# Enable credentials in config.yaml
# credentials:
#   enabled: true
#   file_path: credentials.yaml

droidrun run "Login to my Gmail account" --provider GoogleGenAI --model gemini-2.5-flash
```

### With Custom Tools (SDK Only)

Custom tools and programmatic credentials are only available via the SDK (not CLI).

---

## Troubleshooting

<AccordionGroup>
  <Accordion title="Error: Credential manager not initialized">
    **Cause**: Credentials not enabled or file not found

    **Solution**:
    ```yaml
    # config.yaml
    credentials:
      enabled: true  # Must be true
      file_path: credentials.yaml  # Check path is correct
    ```

    Or pass credentials programmatically:
    ```python
    agent = DroidAgent(..., credentials={"PASSWORD": "secret"})
    ```
  </Accordion>

  <Accordion title="Error: Secret 'X' not found">
    **Cause**: Secret ID doesn't exist or is disabled

    **Solution**:
    ```python
    from droidrun.credential_manager import CredentialManager

    cm = CredentialManager(credentials_path="credentials.yaml")
    print(cm.list_available_secrets())  # Check available secrets
    ```

    Check `credentials.yaml`:
    ```yaml
    secrets:
      X:
        value: "your_value"
        enabled: true  # Must be true
    ```
  </Accordion>

  <Accordion title="Custom tool not working">
    **Cause**: Tool not registered or incorrect signature

    **Solution**:
    1. Check tool signature has `tool_instance` as first param:
       ```python
       def my_tool(tool_instance, arg1: str) -> str:  # â Correct
           pass

       def my_tool(arg1: str) -> str:  # â Wrong
           pass
       ```

    2. Verify custom_tools format:
       ```python
       custom_tools = {
           "tool_name": {
               "arguments": ["arg1"],
               "description": "...",
               "function": my_tool  # Function reference, not call
           }
       }
       ```

    3. Check agent received custom tools:
       ```python
       agent = DroidAgent(..., custom_tools=custom_tools)  # Pass here
       ```
  </Accordion>

  <Accordion title="Agent not using custom tool">
    **Cause**: LLM doesn't understand tool description

    **Solution**: Improve description with clear usage example:
    ```python
    # Bad
    "description": "Send webhook"

    # Good
    "description": 'Send POST request to webhook. Usage: {"action": "send_webhook", "url": "https://webhook.site/abc123", "data": "your message"}'
    ```
  </Accordion>
</AccordionGroup>

---

## Examples Repository

For more complete examples, see:
- [Custom Tools Examples](https://github.com/droidrun/droidrun/tree/main/examples/custom_tools)
- [Credential Management Examples](https://github.com/droidrun/droidrun/tree/main/examples/credentials)
- [Webhook Integration](https://github.com/droidrun/droidrun/tree/main/examples/webhooks)

---

## Next Steps

- Learn about [Agent Execution Modes](/v3/concepts/agent)
- Explore [SDK Reference](/v3/sdk/droid-agent)
- See [Configuration Guide](/v3/guides/configuration)
