---
title: IOSTools
---

UI Actions - Core UI interaction tools for iOS device control.

<a id="droidrun.tools.ios.IOSTools"></a>

## IOSTools

```python
class IOSTools(Tools)
```

Core UI interaction tools for iOS device control.

IOSTools provides an interface for interacting with iOS devices through the DroidRun iOS Portal app. It offers a subset of functionality compared to AdbTools, optimized for iOS's accessibility API and gesture systems.

**Beta Status**: iOS support is currently in beta. Some features may be limited or behave differently than Android.

<a id="droidrun.tools.ios.IOSTools.__init__"></a>

#### IOSTools.\_\_init\_\_

```python
def __init__(
    url: str,
    bundle_identifiers: List[str] | None = None
) -> None
```

Initialize the IOSTools instance.

**Arguments**:

- `url` _str_ - iOS device URL. This is the URL of the iOS Portal app running on the device (e.g., "http://192.168.1.100:8080").
- `bundle_identifiers` _List[str] | None_ - List of bundle identifiers to include in the list of packages (optional). Used to filter apps returned by `list_packages()`.

**Usage:**

```python
from droidrun.tools import IOSTools

# Connect to iOS device
tools = IOSTools(url="http://192.168.1.100:8080")

# With specific bundle identifiers
tools = IOSTools(
    url="http://192.168.1.100:8080",
    bundle_identifiers=["com.example.app1", "com.example.app2"]
)
```

**Setup:**

1. Install the DroidRun iOS Portal app on your iOS device
2. Start the Portal app (it runs a local web server)
3. Note the IP address and port displayed in the app
4. Use that URL to initialize IOSTools

---

## UI Interaction Methods

<a id="droidrun.tools.ios.IOSTools.tap_by_index"></a>

#### IOSTools.tap\_by\_index

```python
def tap_by_index(index: int) -> str
```

Tap on a UI element by its index.

This function uses the cached clickable elements to find the element with the given index and tap on its center coordinates.

**Arguments**:

- `index` _int_ - Index of the element to tap (from accessibility tree)

**Returns**:

- `str` - Result message describing the tapped element

**Usage:**

```python
# Get UI state to populate element cache
state = tools.get_state()

# Tap element at index 3
result = tools.tap_by_index(3)
print(result)
# Output: "Tapped element with index 3 | Text: 'Continue' | Class: Button | Rect: {{100,200},{200,50}}"
```

**Notes:**
- Call `get_state()` first to populate the clickable elements cache
- Returns descriptive error message with available indices if index is invalid
- Waits 0.5 seconds after tap for UI to update

<a id="droidrun.tools.ios.IOSTools.tap"></a>

#### IOSTools.tap

```python
def tap(index: int) -> str
```

Tap on a UI element by its index.

Alias for `tap_by_index()`. This function uses the cached clickable elements from the last `get_state()` call to find the element with the given index and tap on its center coordinates.

**Arguments**:

- `index` _int_ - Index of the element to tap

**Returns**:

- `str` - Result message

<a id="droidrun.tools.ios.IOSTools.swipe"></a>

#### IOSTools.swipe

```python
def swipe(
    start_x: int,
    start_y: int,
    end_x: int,
    end_y: int,
    duration_ms: int = 300
) -> bool
```

Performs a straight-line swipe gesture on the device screen.

iOS swipe gestures are direction-based (up, down, left, right) rather than precise coordinate-based. The function calculates the primary direction from the provided coordinates.

**Arguments**:

- `start_x` _int_ - Starting X coordinate
- `start_y` _int_ - Starting Y coordinate
- `end_x` _int_ - Ending X coordinate
- `end_y` _int_ - Ending Y coordinate
- `duration_ms` _int_ - Duration of swipe in milliseconds (not used in iOS API)

**Returns**:

- `bool` - True if swipe succeeded, False otherwise

**Usage:**

```python
# Swipe up (scroll down content)
tools.swipe(200, 800, 200, 200, duration_ms=300)

# Swipe left
tools.swipe(600, 400, 100, 400, duration_ms=250)

# Swipe right
tools.swipe(100, 400, 600, 400, duration_ms=250)
```

**Notes:**
- The function automatically determines the swipe direction (up, down, left, right) based on coordinate differences
- `duration_ms` parameter is accepted but not used by the iOS gesture API

<a id="droidrun.tools.ios.IOSTools.drag"></a>

#### IOSTools.drag

```python
def drag(
    start_x: int,
    start_y: int,
    end_x: int,
    end_y: int,
    duration_ms: int = 3000
) -> bool
```

Drag from the given start coordinates to the given end coordinates.

**Arguments**:

- `start_x` _int_ - Starting X coordinate
- `start_y` _int_ - Starting Y coordinate
- `end_x` _int_ - Ending X coordinate
- `end_y` _int_ - Ending Y coordinate
- `duration_ms` _int_ - Duration of drag in milliseconds

**Returns**:

- `bool` - False (not implemented for iOS)

**Status:**
- ⚠️ **Not implemented** - Drag gestures are not yet supported on iOS

<a id="droidrun.tools.ios.IOSTools.input_text"></a>

#### IOSTools.input\_text

```python
def input_text(text: str) -> str
```

Input text on the iOS device.

**Arguments**:

- `text` _str_ - Text to input. Can contain spaces, newlines, and special characters including non-ASCII.

**Returns**:

- `str` - Result message

**Usage:**

```python
# Tap text field first to focus it
tools.tap_by_index(5)

# Input text
result = tools.input_text("Hello World")

# Unicode support
result = tools.input_text("你好世界")

# Multiline text
result = tools.input_text("Line 1\nLine 2\nLine 3")
```

**Notes:**
- Always tap the text field element before calling `input_text()`
- Uses the last tapped element's rect for text input targeting
- Waits 0.5 seconds after input for UI to update
- Supports Unicode characters and special characters

<a id="droidrun.tools.ios.IOSTools.back"></a>

#### IOSTools.back

```python
def back() -> str
```

Go back on the current view.

**Status:**
- ⚠️ **Not implemented** - iOS does not have a universal back button like Android

**Raises**:
- `NotImplementedError`

<a id="droidrun.tools.ios.IOSTools.press_key"></a>

#### IOSTools.press\_key

```python
def press_key(keycode: int) -> str
```

Press a key on the iOS device.

**iOS Key codes:**
- `0`: HOME
- `4`: ACTION
- `5`: CAMERA

**Arguments**:

- `keycode` _int_ - iOS keycode to press

**Returns**:

- `str` - Result message

**Usage:**

```python
# Press home button
tools.press_key(0)

# Press action button
tools.press_key(4)

# Press camera button
tools.press_key(5)
```

**Notes:**
- iOS has a limited set of physical key codes compared to Android
- Most navigation uses gesture-based interactions

---

## App Management Methods

<a id="droidrun.tools.ios.IOSTools.start_app"></a>

#### IOSTools.start\_app

```python
def start_app(package: str, activity: str = "") -> str
```

Start an app on the iOS device.

**Arguments**:

- `package` _str_ - Bundle identifier (e.g., "com.apple.MobileSMS", "com.apple.mobilesafari")
- `activity` _str_ - Optional activity name (not used on iOS, provided for API compatibility)

**Returns**:

- `str` - Result message

**Usage:**

```python
# Launch Messages app
result = tools.start_app("com.apple.MobileSMS")

# Launch Safari
result = tools.start_app("com.apple.mobilesafari")

# Launch Settings
result = tools.start_app("com.apple.Preferences")
```

**Common iOS bundle identifiers:**
- Messages: `com.apple.MobileSMS`
- Safari: `com.apple.mobilesafari`
- Settings: `com.apple.Preferences`
- Mail: `com.apple.mobilemail`
- Calendar: `com.apple.mobilecal`
- Photos: `com.apple.mobileslideshow`
- Maps: `com.apple.Maps`
- Contacts: `com.apple.MobileAddressBook`

**Notes:**
- Waits 1 second after launch for app to start
- `activity` parameter is ignored on iOS

<a id="droidrun.tools.ios.IOSTools.list_packages"></a>

#### IOSTools.list\_packages

```python
def list_packages(include_system_apps: bool = True) -> List[str]
```

List installed packages on the device.

**Arguments**:

- `include_system_apps` _bool_ - Whether to include system apps (default: True)

**Returns**:

- `List[str]` - List of bundle identifiers

**Usage:**

```python
# All apps (system + custom)
packages = tools.list_packages()
print(packages)

# Custom apps only
packages = tools.list_packages(include_system_apps=False)
```

**Notes:**
- System apps include common iOS apps (Settings, Safari, Messages, etc.)
- Custom apps are those provided in `bundle_identifiers` during initialization

---

## State and Screenshot Methods

<a id="droidrun.tools.ios.IOSTools.get_state"></a>

#### IOSTools.get\_state

```python
def get_state() -> Dict[str, Any]
```

Get the accessibility tree and phone state.

This is the primary method for retrieving UI information from the iOS device. It combines accessibility tree (UI elements) and phone state (current activity, keyboard visibility) into a single response.

**Returns**:

- `Dict[str, Any]` - Dictionary containing 'a11y_tree' and 'phone_state' data:
  - `a11y_tree`: List of interactive UI elements (buttons, text fields, etc.)
  - `phone_state`: Current activity name, keyboard visibility

**Usage:**

```python
state = tools.get_state()

# Access accessibility tree
for element in state['a11y_tree']:
    print(f"Index {element['index']}: {element['text']} ({element['className']})")

# Access phone state
current_activity = state['phone_state']['current_activity']
keyboard_shown = state['phone_state']['keyboard_shown']
```

**Element structure:**

```python
{
    "index": 3,
    "type": "Button",
    "className": "Button",
    "text": "Continue",
    "label": "Continue",
    "identifier": "continueButton",
    "placeholder": "",
    "value": "",
    "bounds": "100,200,300,250",  # left,top,right,bottom
    "rect": "100,200,200,50",      # x,y,width,height (iOS format)
    "x": 100,
    "y": 200,
    "width": 200,
    "height": 50,
    "center_x": 200,
    "center_y": 225
}
```

**Interactive element types:**
- Button
- SearchField
- TextField
- Cell
- Switch
- Slider
- Stepper
- Picker
- Link

**Notes:**
- Only interactive elements are included in the accessibility tree
- Non-interactive elements (static text, images, etc.) are filtered out
- iOS accessibility API provides more detailed element information than Android

<a id="droidrun.tools.ios.IOSTools.take_screenshot"></a>

#### IOSTools.take\_screenshot

```python
def take_screenshot() -> Tuple[str, bytes]
```

Take a screenshot of the iOS device.

This function captures the current screen and stores the screenshot with timestamp for trajectory recording.

**Returns**:

- `Tuple[str, bytes]` - Tuple of (format, image_bytes) where format is "PNG" and image_bytes is the PNG image data

**Usage:**

```python
# Take screenshot
format, image_bytes = tools.take_screenshot()

# Save to file
with open("ios_screenshot.png", "wb") as f:
    f.write(image_bytes)
```

---

## Memory and Completion Methods

<a id="droidrun.tools.ios.IOSTools.remember"></a>

#### IOSTools.remember

```python
def remember(information: str) -> str
```

Store important information to remember for future context.

This information will be included in future LLM prompts to help maintain context across interactions. Use this for critical facts, observations, or user preferences that should influence future decisions.

**Arguments**:

- `information` _str_ - The information to remember

**Returns**:

- `str` - Confirmation message

**Usage:**

```python
# Remember user preferences
tools.remember("User prefers light mode")

# Remember important state
tools.remember("Calendar event created for 3pm tomorrow")

# Remember task progress
tools.remember("Already logged into email account")
```

**Notes:**
- Memory is limited to 10 most recent items
- Memory persists for the duration of the agent's execution

<a id="droidrun.tools.ios.IOSTools.get_memory"></a>

#### IOSTools.get\_memory

```python
def get_memory() -> List[str]
```

Retrieve all stored memory items.

**Returns**:

- `List[str]` - List of stored memory items

**Usage:**

```python
memory = tools.get_memory()
for item in memory:
    print(f"- {item}")
```

<a id="droidrun.tools.ios.IOSTools.complete"></a>

#### IOSTools.complete

```python
def complete(success: bool, reason: str = "")
```

Mark the task as finished.

**Arguments**:

- `success` _bool_ - Indicates if the task was successful
- `reason` _str_ - Reason for failure/success (required if success=False)

**Usage:**

```python
# Success
tools.complete(success=True, reason="Successfully sent iMessage to John")

# Failure
tools.complete(success=False, reason="Could not find contact 'John' in Contacts app")
```

---

## Properties

**Instance variables:**

- `url` - iOS device URL
- `clickable_elements_cache` - Cached UI elements from last `get_state()` call
- `memory` - List of remembered information items
- `screenshots` - List of captured screenshots with timestamps
- `last_tapped_rect` - Rect of last tapped element (used for text input)
- `bundle_identifiers` - List of custom bundle identifiers
- `finished` - Boolean indicating if task is complete
- `success` - Boolean indicating if task succeeded
- `reason` - String describing success/failure reason

---

## iOS-Specific Considerations

**Differences from Android:**

1. **No back button**: iOS relies on navigation bars and gestures. Use the navigation UI elements instead.
2. **Direction-based swipes**: Swipe gestures use directional API (up, down, left, right) rather than precise coordinates.
3. **Bundle identifiers**: iOS uses bundle identifiers (e.g., "com.apple.MobileSMS") instead of Android package names.
4. **Limited key codes**: iOS has fewer physical key codes compared to Android.
5. **Accessibility tree**: iOS provides richer element information (label, identifier, placeholder, value).
6. **Element filtering**: Only interactive elements (buttons, text fields, etc.) are included in the accessibility tree.

**Connection setup:**

Unlike Android's ADB connection, iOS requires:
1. Install DroidRun iOS Portal app on device
2. Run Portal app (starts web server)
3. Connect to device's IP address and port
4. Ensure device and computer are on same network

**Beta limitations:**

- Drag gestures not implemented
- Back navigation not available (use UI elements)
- Limited to HTTP communication (no USB debugging like Android)
- Some advanced features may not work as expected

---

## Example Workflow

```python
from droidrun.tools import IOSTools

# Initialize tools with device URL
tools = IOSTools(url="http://192.168.1.100:8080")

# Start Messages app
tools.start_app("com.apple.MobileSMS")

# Get UI state
state = tools.get_state()
print(f"Current activity: {state['phone_state']['current_activity']}")

# Find and tap compose button
for element in state['a11y_tree']:
    if 'compose' in element['label'].lower():
        tools.tap_by_index(element['index'])
        break

# Get updated state
state = tools.get_state()

# Find and tap recipient field
for element in state['a11y_tree']:
    if element['type'] == 'TextField' and 'to' in element['label'].lower():
        tools.tap_by_index(element['index'])
        break

# Input recipient
tools.input_text("John")

# Find message field
state = tools.get_state()
for element in state['a11y_tree']:
    if element['type'] == 'TextField' and 'message' in element['label'].lower():
        tools.tap_by_index(element['index'])
        break

# Input message
tools.input_text("Hello from DroidRun!")

# Find and tap send button
state = tools.get_state()
for element in state['a11y_tree']:
    if 'send' in element['label'].lower():
        tools.tap_by_index(element['index'])
        break

# Take screenshot
format, screenshot = tools.take_screenshot()
with open("ios_message_sent.png", "wb") as f:
    f.write(screenshot)

# Remember result
tools.remember("Sent message to John via iMessage")

# Complete task
tools.complete(success=True, reason="Successfully sent iMessage to John")
```

---

## See Also

- [AdbTools](/docs/v4/sdk/adb-tools) - Android device control
- [Tools Base Class](/docs/v4/sdk/base-tools) - Common interface and patterns
- [Device Setup Guide](/docs/v4/guides/device-setup) - iOS device configuration
