---
title: DroidAgent
---

DroidAgent - A wrapper class that coordinates the planning and execution of tasks to achieve a user's goal on an Android or iOS device.

<a id="droidrun.agent.droid.droid_agent.DroidAgent"></a>

## DroidAgent

```python
class DroidAgent(Workflow)
```

A wrapper class that coordinates between agents to achieve a user's goal.

**Architecture:**
- When `reasoning=False`: Uses CodeActAgent directly for immediate execution
- When `reasoning=True`: Uses ManagerAgent (planning) + ExecutorAgent (actions) + ScripterAgent (off-device operations)

<a id="droidrun.agent.droid.droid_agent.DroidAgent.__init__"></a>

#### DroidAgent.\_\_init\_\_

```python
def __init__(
    goal: str,
    config: DroidRunConfig | None = None,
    llms: dict[str, LLM] | LLM | None = None,
    agent_config: AgentConfig | None = None,
    device_config: DeviceConfig | None = None,
    tools: "Tools | ToolsConfig | None" = None,
    logging_config: LoggingConfig | None = None,
    tracing_config: TracingConfig | None = None,
    telemetry_config: TelemetryConfig | None = None,
    custom_tools: dict = None,
    credentials: "CredentialsConfig | dict | None" = None,
    variables: dict | None = None,
    output_model: Type[BaseModel] | None = None,
    timeout: int = 1000,
    *args,
    **kwargs
)
```

Initialize the DroidAgent wrapper.

**Arguments**:

- `goal` _str_ - User's goal or command to execute
- `config` _DroidRunConfig | None_ - Full configuration object (required if llms not provided). Contains agent settings, LLM profiles, device config, and more. If provided, individual config overrides (agent_config, device_config, etc.) take precedence.
- `llms` _dict[str, LLM] | LLM | None_ - Optional LLM configuration:
  - `dict[str, LLM]`: Agent-specific LLMs with keys: "manager", "executor", "codeact", "text_manipulator", "app_opener", "scripter", "structured_output"
  - `LLM`: Single LLM instance used for all agents
  - `None`: LLMs will be loaded from config.llm_profiles
- `agent_config` _AgentConfig | None_ - Agent configuration override (max_steps, reasoning mode, vision settings, prompts). Overrides config.agent if provided.
- `device_config` _DeviceConfig | None_ - Device configuration override (serial, platform, use_tcp). Overrides config.device if provided.
- `tools` _Tools | ToolsConfig | None_ - Tools configuration:
  - `Tools`: Pre-configured Tools instance (AdbTools or IOSTools)
  - `ToolsConfig`: Configuration for creating tools (e.g., allow_drag)
  - `None`: Tools will be created from config.tools and device_config
- `logging_config` _LoggingConfig | None_ - Logging configuration override (debug, save_trajectory). Overrides config.logging if provided.
- `tracing_config` _TracingConfig | None_ - Tracing configuration override (enabled). Overrides config.tracing if provided.
- `telemetry_config` _TelemetryConfig | None_ - Telemetry configuration override (enabled). Overrides config.telemetry if provided.
- `custom_tools` _dict | None_ - Custom tool definitions. Format: `{"tool_name": {"signature": "...", "description": "...", "function": callable}}`. These are merged with auto-generated credential tools.
- `credentials` _CredentialsConfig | dict | None_ - Credential configuration:
  - `CredentialsConfig`: From config.credentials (enabled, file_path)
  - `dict`: Direct credential mapping `{"SECRET_ID": "value"}`
  - `None`: Uses config.credentials if available
- `variables` _dict | None_ - Custom variables accessible throughout execution. Available in shared_state.custom_variables.
- `output_model` _Type[BaseModel] | None_ - Pydantic model for structured output extraction from final answer. If provided, the final answer will be parsed into this model.
- `timeout` _int_ - Workflow timeout in seconds (default: 1000)

**Config-driven initialization pattern (recommended):**

```python
from droidrun import DroidAgent, DroidRunConfig

# Load config from config.yaml
config = DroidRunConfig.from_yaml("config.yaml")

# Create agent (LLMs loaded from config.llm_profiles)
agent = DroidAgent(
    goal="Open Chrome and search for DroidRun",
    config=config
)

# Run agent
handler = agent.run()
result = await handler
```

**Custom LLM dictionary pattern:**

```python
from droidrun import DroidAgent
from llama_index.llms.openai import OpenAI
from llama_index.llms.anthropic import Anthropic

# Create custom LLMs
llms = {
    "manager": Anthropic(model="claude-sonnet-4-5", temperature=0.2),
    "executor": Anthropic(model="claude-sonnet-4-5", temperature=0.1),
    "codeact": OpenAI(model="gpt-4o", temperature=0.2),
    "text_manipulator": OpenAI(model="gpt-4o-mini", temperature=0.3),
    "app_opener": OpenAI(model="gpt-4o-mini", temperature=0.0),
    "scripter": OpenAI(model="gpt-4o", temperature=0.1),
    "structured_output": OpenAI(model="gpt-4o-mini", temperature=0.0),
}

# Create agent with custom LLMs
agent = DroidAgent(
    goal="Send a message to John",
    llms=llms,
    config=config
)

handler = agent.run()
result = await handler
```

**Single LLM pattern:**

```python
from droidrun import DroidAgent
from llama_index.llms.openai import OpenAI

# Use same LLM for all agents
llm = OpenAI(model="gpt-4o", temperature=0.2)

agent = DroidAgent(
    goal="Take a screenshot and save it",
    llms=llm,
    config=config
)

handler = agent.run()
result = await handler
```

**Custom tools and credentials:**

```python
from droidrun import DroidAgent

# Define custom tool
def search_database(query: str) -> str:
    """Search the local database."""
    # Your implementation
    return f"Results for: {query}"

custom_tools = {
    "search_database": {
        "signature": "search_database(query: str) -> str",
        "description": "Search the local database for information",
        "function": search_database
    }
}

# Provide credentials directly
credentials = {
    "GMAIL_USERNAME": "user@gmail.com",
    "GMAIL_PASSWORD": "secret123"
}

agent = DroidAgent(
    goal="Search database and email results",
    config=config,
    custom_tools=custom_tools,
    credentials=credentials
)

handler = agent.run()
result = await handler
```

**Structured output extraction:**

```python
from droidrun import DroidAgent
from pydantic import BaseModel, Field

# Define output schema
class WeatherInfo(BaseModel):
    """Weather information."""
    temperature: float = Field(description="Temperature in Celsius")
    condition: str = Field(description="Weather condition")
    humidity: int = Field(description="Humidity percentage")

agent = DroidAgent(
    goal="Open weather app and get current weather",
    config=config,
    output_model=WeatherInfo
)

handler = agent.run()
result = await handler

# Access structured output
if result["success"] and result["structured_output"]:
    weather = result["structured_output"]  # WeatherInfo object
    print(f"Temperature: {weather.temperature}Â°C")
    print(f"Condition: {weather.condition}")
```

<a id="droidrun.agent.droid.droid_agent.DroidAgent.run"></a>

#### DroidAgent.run

```python
def run(*args, **kwargs) -> WorkflowHandler
```

Run the DroidAgent workflow.

**Returns**:

- `WorkflowHandler` - Async workflow handler. Await this to get the final result.

**Result structure:**

```python
{
    "success": bool,          # True if task completed successfully
    "reason": str,            # Success message or failure reason
    "steps": int,             # Number of steps executed
    "structured_output": Any  # Parsed Pydantic model (if output_model provided)
}
```

**Usage:**

```python
# Synchronous-style usage
agent = DroidAgent(goal="...", config=config)
handler = agent.run()
result = await handler

print(f"Success: {result['success']}")
print(f"Reason: {result['reason']}")
print(f"Steps: {result['steps']}")
```

**Streaming events:**

```python
agent = DroidAgent(goal="...", config=config)
handler = agent.run()

# Stream events as they occur
async for event in handler.stream_events():
    if isinstance(event, ManagerInputEvent):
        print("Manager is planning...")
    elif isinstance(event, ExecutorInputEvent):
        print("Executor is taking action...")
    elif isinstance(event, TapActionEvent):
        print(f"Tapping element at {event.x}, {event.y}")

# Get final result
result = await handler
```

## Event Types

DroidAgent emits various events during execution:

**Workflow Events:**
- `StartEvent` - Workflow started
- `ManagerInputEvent` - Manager planning phase started
- `ManagerPlanEvent` - Manager created a plan
- `ExecutorInputEvent` - Executor action phase started
- `ExecutorResultEvent` - Executor completed an action
- `ScripterExecutorInputEvent` - ScripterAgent started
- `ScripterExecutorResultEvent` - ScripterAgent completed
- `CodeActExecuteEvent` - CodeActAgent started (direct mode)
- `CodeActResultEvent` - CodeActAgent completed
- `FinalizeEvent` - Workflow finalizing
- `StopEvent` - Workflow completed

**Action Events:**
- `TapActionEvent` - UI element tapped
- `SwipeActionEvent` - Swipe gesture performed
- `DragActionEvent` - Drag gesture performed
- `InputTextActionEvent` - Text input
- `KeyPressActionEvent` - Key press action
- `StartAppEvent` - App launched

**State Events:**
- `ScreenshotEvent` - Screenshot captured
- `RecordUIStateEvent` - UI state recorded
- `MacroEvent` - Macro action recorded
- `EpisodicMemoryEvent` - Memory updated

## Configuration

DroidAgent uses a hierarchical configuration system. See the [Configuration Guide](/docs/v4/guides/configuration) for details.

**Key configuration options:**

```yaml
agent:
  max_steps: 15           # Maximum execution steps
  reasoning: false        # Enable Manager/Executor workflow

  codeact:
    vision: false         # Enable screenshot analysis
    safe_execution: false # Restrict code execution

  manager:
    vision: false         # Enable screenshot analysis

  executor:
    vision: false         # Enable screenshot analysis

device:
  serial: null            # Device serial (null = auto-detect)
  platform: android       # "android" or "ios"
  use_tcp: false          # TCP vs content provider

logging:
  debug: false            # Debug logging
  save_trajectory: none   # Trajectory saving: "none", "step", "action"

tracing:
  enabled: false          # Arize Phoenix tracing
```

## Advanced Usage

**Custom Tools instance:**

```python
from droidrun import DroidAgent, AdbTools

# Pre-configure tools
tools = AdbTools(serial="emulator-5554", use_tcp=True)

agent = DroidAgent(
    goal="Open settings",
    config=config,
    tools=tools  # Use pre-configured tools
)

handler = agent.run()
result = await handler
```

**Custom variables:**

```python
agent = DroidAgent(
    goal="Complete task using context",
    config=config,
    variables={
        "user_name": "Alice",
        "project_id": "12345",
        "api_endpoint": "https://api.example.com"
    }
)

handler = agent.run()
result = await handler
```

Variables are accessible in shared_state.custom_variables throughout execution and can be referenced in custom tools or scripts.

## Notes

- **Config requirement**: Either `config` or `llms` must be provided. If `llms` is not provided, `config` is required to load LLMs from profiles.
- **Vision mode**: Enabling vision (agent_config.*.vision = True) increases token usage as screenshots are sent to the LLM.
- **Reasoning mode**: `reasoning=True` uses Manager/Executor workflow for complex planning. `reasoning=False` uses CodeActAgent for direct execution.
- **Safe execution**: When enabled, restricts imports and builtins in CodeActAgent and ScripterAgent (see safe_execution config).
- **Timeout**: Default is 1000 seconds. Increase for long-running tasks.
- **Credentials**: Credentials are automatically injected as custom tools (e.g., `get_username()`, `get_password()`).
